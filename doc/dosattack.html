<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Python: module dosattack</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head><body bgcolor="#f0f0f8">

<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="heading">
<tr bgcolor="#7799ee">
<td valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial">&nbsp;<br><big><big><strong>dosattack</strong></big></big></font></td
><td align=right valign=bottom
><font color="#ffffff" face="helvetica, arial"><a href=".">index</a><br><a href="file:/home/raul/roboticpark_ws/src/roboticpark_cyberattacks/roboticpark_cyberattacks/dosattack.py">/home/raul/roboticpark_ws/src/roboticpark_cyberattacks/roboticpark_cyberattacks/dosattack.py</a></font></td></tr></table>
    <p></p>
<p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#aa55cc">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Modules</strong></big></font></td></tr>
    
<tr><td bgcolor="#aa55cc"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><table width="100%" summary="list"><tr><td width="25%" valign=top><a href="concurrent.html">concurrent</a><br>
<a href="importlib.html">importlib</a><br>
</td><td width="25%" valign=top><a href="random.html">random</a><br>
<a href="rclpy.html">rclpy</a><br>
</td><td width="25%" valign=top><a href="socket.html">socket</a><br>
<a href="sys.html">sys</a><br>
</td><td width="25%" valign=top></td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ee77aa">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Classes</strong></big></font></td></tr>
    
<tr><td bgcolor="#ee77aa"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl>
<dt><font face="helvetica, arial"><a href="rclpy.node.html#Node">rclpy.node.Node</a>(<a href="builtins.html#object">builtins.object</a>)
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="dosattack.html#dosnode">dosnode</a>
</font></dt></dl>
</dd>
</dl>
 <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="dosnode">class <strong>dosnode</strong></a>(<a href="rclpy.node.html#Node">rclpy.node.Node</a>)</font></td></tr>
    
<tr><td bgcolor="#ffc8d8"><tt>&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="dosattack.html#dosnode">dosnode</a></dd>
<dd><a href="rclpy.node.html#Node">rclpy.node.Node</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="dosnode-__init__"><strong>__init__</strong></a>(self)</dt><dd><tt>Create&nbsp;a&nbsp;<a href="rclpy.node.html#Node">Node</a>.<br>
&nbsp;<br>
:param&nbsp;node_name:&nbsp;A&nbsp;name&nbsp;to&nbsp;give&nbsp;to&nbsp;this&nbsp;node.&nbsp;Validated&nbsp;by&nbsp;:func:`validate_node_name`.<br>
:param&nbsp;context:&nbsp;The&nbsp;context&nbsp;to&nbsp;be&nbsp;associated&nbsp;with,&nbsp;or&nbsp;``None``&nbsp;for&nbsp;the&nbsp;default&nbsp;global<br>
&nbsp;&nbsp;&nbsp;&nbsp;context.<br>
:param&nbsp;cli_args:&nbsp;A&nbsp;list&nbsp;of&nbsp;strings&nbsp;of&nbsp;command&nbsp;line&nbsp;args&nbsp;to&nbsp;be&nbsp;used&nbsp;only&nbsp;by&nbsp;this&nbsp;node.<br>
&nbsp;&nbsp;&nbsp;&nbsp;These&nbsp;arguments&nbsp;are&nbsp;used&nbsp;to&nbsp;extract&nbsp;remappings&nbsp;used&nbsp;by&nbsp;the&nbsp;node&nbsp;and&nbsp;other&nbsp;ROS&nbsp;specific<br>
&nbsp;&nbsp;&nbsp;&nbsp;settings,&nbsp;as&nbsp;well&nbsp;as&nbsp;user&nbsp;defined&nbsp;non-ROS&nbsp;arguments.<br>
:param&nbsp;namespace:&nbsp;The&nbsp;namespace&nbsp;to&nbsp;which&nbsp;relative&nbsp;topic&nbsp;and&nbsp;service&nbsp;names&nbsp;will&nbsp;be&nbsp;prefixed.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Validated&nbsp;by&nbsp;:func:`validate_namespace`.<br>
:param&nbsp;use_global_arguments:&nbsp;``False``&nbsp;if&nbsp;the&nbsp;node&nbsp;should&nbsp;ignore&nbsp;process-wide&nbsp;command&nbsp;line<br>
&nbsp;&nbsp;&nbsp;&nbsp;args.<br>
:param&nbsp;enable_rosout:&nbsp;``False``&nbsp;if&nbsp;the&nbsp;node&nbsp;should&nbsp;ignore&nbsp;rosout&nbsp;logging.<br>
:param&nbsp;start_parameter_services:&nbsp;``False``&nbsp;if&nbsp;the&nbsp;node&nbsp;should&nbsp;not&nbsp;create&nbsp;parameter<br>
&nbsp;&nbsp;&nbsp;&nbsp;services.<br>
:param&nbsp;parameter_overrides:&nbsp;A&nbsp;list&nbsp;of&nbsp;overrides&nbsp;for&nbsp;initial&nbsp;values&nbsp;for&nbsp;parameters&nbsp;declared<br>
&nbsp;&nbsp;&nbsp;&nbsp;on&nbsp;the&nbsp;node.<br>
:param&nbsp;allow_undeclared_parameters:&nbsp;True&nbsp;if&nbsp;undeclared&nbsp;parameters&nbsp;are&nbsp;allowed.<br>
&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;flag&nbsp;affects&nbsp;the&nbsp;behavior&nbsp;of&nbsp;parameter-related&nbsp;operations.<br>
:param&nbsp;automatically_declare_parameters_from_overrides:&nbsp;If&nbsp;True,&nbsp;the&nbsp;"parameter&nbsp;overrides"<br>
&nbsp;&nbsp;&nbsp;&nbsp;will&nbsp;be&nbsp;used&nbsp;to&nbsp;implicitly&nbsp;declare&nbsp;parameters&nbsp;on&nbsp;the&nbsp;node&nbsp;during&nbsp;creation.</tt></dd></dl>

<hr>
Methods inherited from <a href="rclpy.node.html#Node">rclpy.node.Node</a>:<br>
<dl><dt><a name="dosnode-add_on_set_parameters_callback"><strong>add_on_set_parameters_callback</strong></a>(self, callback: Callable[[List[rclpy.parameter.Parameter]], rcl_interfaces.msg._set_parameters_result.SetParametersResult]) -&gt; None</dt><dd><tt>Add&nbsp;a&nbsp;callback&nbsp;in&nbsp;front&nbsp;to&nbsp;the&nbsp;list&nbsp;of&nbsp;callbacks.<br>
&nbsp;<br>
Calling&nbsp;this&nbsp;function&nbsp;will&nbsp;add&nbsp;a&nbsp;callback&nbsp;in&nbsp;self.<strong>_parameter_callbacks</strong>&nbsp;list.<br>
&nbsp;<br>
It&nbsp;is&nbsp;considered&nbsp;bad&nbsp;practice&nbsp;to&nbsp;reject&nbsp;changes&nbsp;for&nbsp;"unknown"&nbsp;parameters&nbsp;as&nbsp;this&nbsp;prevents<br>
other&nbsp;parts&nbsp;of&nbsp;the&nbsp;node&nbsp;(that&nbsp;may&nbsp;be&nbsp;aware&nbsp;of&nbsp;these&nbsp;parameters)&nbsp;from&nbsp;handling&nbsp;them.<br>
&nbsp;<br>
:param&nbsp;callback:&nbsp;The&nbsp;function&nbsp;that&nbsp;is&nbsp;called&nbsp;whenever&nbsp;parameters&nbsp;are&nbsp;set&nbsp;for&nbsp;the&nbsp;node.</tt></dd></dl>

<dl><dt><a name="dosnode-add_waitable"><strong>add_waitable</strong></a>(self, waitable: rclpy.waitable.Waitable) -&gt; None</dt><dd><tt>Add&nbsp;a&nbsp;class&nbsp;that&nbsp;is&nbsp;capable&nbsp;of&nbsp;adding&nbsp;things&nbsp;to&nbsp;the&nbsp;wait&nbsp;set.<br>
&nbsp;<br>
:param&nbsp;waitable:&nbsp;An&nbsp;instance&nbsp;of&nbsp;a&nbsp;waitable&nbsp;that&nbsp;the&nbsp;node&nbsp;will&nbsp;add&nbsp;to&nbsp;the&nbsp;waitset.</tt></dd></dl>

<dl><dt><a name="dosnode-count_publishers"><strong>count_publishers</strong></a>(self, topic_name: str) -&gt; int</dt><dd><tt>Return&nbsp;the&nbsp;number&nbsp;of&nbsp;publishers&nbsp;on&nbsp;a&nbsp;given&nbsp;topic.<br>
&nbsp;<br>
`topic_name`&nbsp;may&nbsp;be&nbsp;a&nbsp;relative,&nbsp;private,&nbsp;or&nbsp;fully&nbsp;qualified&nbsp;topic&nbsp;name.<br>
A&nbsp;relative&nbsp;or&nbsp;private&nbsp;topic&nbsp;is&nbsp;expanded&nbsp;using&nbsp;this&nbsp;node's&nbsp;namespace&nbsp;and&nbsp;name.<br>
The&nbsp;queried&nbsp;topic&nbsp;name&nbsp;is&nbsp;not&nbsp;remapped.<br>
&nbsp;<br>
:param&nbsp;topic_name:&nbsp;the&nbsp;topic_name&nbsp;on&nbsp;which&nbsp;to&nbsp;count&nbsp;the&nbsp;number&nbsp;of&nbsp;publishers.<br>
:return:&nbsp;the&nbsp;number&nbsp;of&nbsp;publishers&nbsp;on&nbsp;the&nbsp;topic.</tt></dd></dl>

<dl><dt><a name="dosnode-count_subscribers"><strong>count_subscribers</strong></a>(self, topic_name: str) -&gt; int</dt><dd><tt>Return&nbsp;the&nbsp;number&nbsp;of&nbsp;subscribers&nbsp;on&nbsp;a&nbsp;given&nbsp;topic.<br>
&nbsp;<br>
`topic_name`&nbsp;may&nbsp;be&nbsp;a&nbsp;relative,&nbsp;private,&nbsp;or&nbsp;fully&nbsp;qualified&nbsp;topic&nbsp;name.<br>
A&nbsp;relative&nbsp;or&nbsp;private&nbsp;topic&nbsp;is&nbsp;expanded&nbsp;using&nbsp;this&nbsp;node's&nbsp;namespace&nbsp;and&nbsp;name.<br>
The&nbsp;queried&nbsp;topic&nbsp;name&nbsp;is&nbsp;not&nbsp;remapped.<br>
&nbsp;<br>
:param&nbsp;topic_name:&nbsp;the&nbsp;topic_name&nbsp;on&nbsp;which&nbsp;to&nbsp;count&nbsp;the&nbsp;number&nbsp;of&nbsp;subscribers.<br>
:return:&nbsp;the&nbsp;number&nbsp;of&nbsp;subscribers&nbsp;on&nbsp;the&nbsp;topic.</tt></dd></dl>

<dl><dt><a name="dosnode-create_client"><strong>create_client</strong></a>(self, srv_type, srv_name: str, *, qos_profile: rclpy.qos.QoSProfile = &lt;rclpy.qos.QoSProfile object at 0x7f55b46a0c10&gt;, callback_group: Optional[rclpy.callback_groups.CallbackGroup] = None) -&gt; rclpy.client.Client</dt><dd><tt>Create&nbsp;a&nbsp;new&nbsp;service&nbsp;client.<br>
&nbsp;<br>
:param&nbsp;srv_type:&nbsp;The&nbsp;service&nbsp;type.<br>
:param&nbsp;srv_name:&nbsp;The&nbsp;name&nbsp;of&nbsp;the&nbsp;service.<br>
:param&nbsp;qos_profile:&nbsp;The&nbsp;quality&nbsp;of&nbsp;service&nbsp;profile&nbsp;to&nbsp;apply&nbsp;the&nbsp;service&nbsp;client.<br>
:param&nbsp;callback_group:&nbsp;The&nbsp;callback&nbsp;group&nbsp;for&nbsp;the&nbsp;service&nbsp;client.&nbsp;If&nbsp;``None``,&nbsp;then&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;nodes&nbsp;default&nbsp;callback&nbsp;group&nbsp;is&nbsp;used.</tt></dd></dl>

<dl><dt><a name="dosnode-create_guard_condition"><strong>create_guard_condition</strong></a>(self, callback: Callable, callback_group: Optional[rclpy.callback_groups.CallbackGroup] = None) -&gt; rclpy.guard_condition.GuardCondition</dt><dd><tt>Create&nbsp;a&nbsp;new&nbsp;guard&nbsp;condition.</tt></dd></dl>

<dl><dt><a name="dosnode-create_publisher"><strong>create_publisher</strong></a>(self, msg_type, topic: str, qos_profile: Union[rclpy.qos.QoSProfile, int], *, callback_group: Optional[rclpy.callback_groups.CallbackGroup] = None, event_callbacks: Optional[rclpy.qos_event.PublisherEventCallbacks] = None, qos_overriding_options: Optional[rclpy.qos_overriding_options.QoSOverridingOptions] = None, publisher_class: Type[rclpy.publisher.Publisher] = &lt;class 'rclpy.publisher.Publisher'&gt;) -&gt; rclpy.publisher.Publisher</dt><dd><tt>Create&nbsp;a&nbsp;new&nbsp;publisher.<br>
&nbsp;<br>
:param&nbsp;msg_type:&nbsp;The&nbsp;type&nbsp;of&nbsp;ROS&nbsp;messages&nbsp;the&nbsp;publisher&nbsp;will&nbsp;publish.<br>
:param&nbsp;topic:&nbsp;The&nbsp;name&nbsp;of&nbsp;the&nbsp;topic&nbsp;the&nbsp;publisher&nbsp;will&nbsp;publish&nbsp;to.<br>
:param&nbsp;qos_profile:&nbsp;A&nbsp;QoSProfile&nbsp;or&nbsp;a&nbsp;history&nbsp;depth&nbsp;to&nbsp;apply&nbsp;to&nbsp;the&nbsp;publisher.<br>
&nbsp;&nbsp;In&nbsp;the&nbsp;case&nbsp;that&nbsp;a&nbsp;history&nbsp;depth&nbsp;is&nbsp;provided,&nbsp;the&nbsp;QoS&nbsp;history&nbsp;is&nbsp;set&nbsp;to<br>
&nbsp;&nbsp;KEEP_LAST,&nbsp;the&nbsp;QoS&nbsp;history&nbsp;depth&nbsp;is&nbsp;set&nbsp;to&nbsp;the&nbsp;value<br>
&nbsp;&nbsp;of&nbsp;the&nbsp;parameter,&nbsp;and&nbsp;all&nbsp;other&nbsp;QoS&nbsp;settings&nbsp;are&nbsp;set&nbsp;to&nbsp;their&nbsp;default&nbsp;values.<br>
:param&nbsp;callback_group:&nbsp;The&nbsp;callback&nbsp;group&nbsp;for&nbsp;the&nbsp;publisher's&nbsp;event&nbsp;handlers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;``None``,&nbsp;then&nbsp;the&nbsp;node's&nbsp;default&nbsp;callback&nbsp;group&nbsp;is&nbsp;used.<br>
:param&nbsp;event_callbacks:&nbsp;User-defined&nbsp;callbacks&nbsp;for&nbsp;middleware&nbsp;events.<br>
:return:&nbsp;The&nbsp;new&nbsp;publisher.</tt></dd></dl>

<dl><dt><a name="dosnode-create_rate"><strong>create_rate</strong></a>(self, frequency: float, clock: Optional[rclpy.clock.Clock] = None) -&gt; rclpy.timer.Rate</dt><dd><tt>Create&nbsp;a&nbsp;Rate&nbsp;object.<br>
&nbsp;<br>
:param&nbsp;frequency:&nbsp;The&nbsp;frequency&nbsp;the&nbsp;Rate&nbsp;runs&nbsp;at&nbsp;(Hz).<br>
:param&nbsp;clock:&nbsp;The&nbsp;clock&nbsp;the&nbsp;Rate&nbsp;gets&nbsp;time&nbsp;from.</tt></dd></dl>

<dl><dt><a name="dosnode-create_service"><strong>create_service</strong></a>(self, srv_type, srv_name: str, callback: Callable[[~SrvTypeRequest, ~SrvTypeResponse], ~SrvTypeResponse], *, qos_profile: rclpy.qos.QoSProfile = &lt;rclpy.qos.QoSProfile object at 0x7f55b46a0c10&gt;, callback_group: Optional[rclpy.callback_groups.CallbackGroup] = None) -&gt; rclpy.service.Service</dt><dd><tt>Create&nbsp;a&nbsp;new&nbsp;service&nbsp;server.<br>
&nbsp;<br>
:param&nbsp;srv_type:&nbsp;The&nbsp;service&nbsp;type.<br>
:param&nbsp;srv_name:&nbsp;The&nbsp;name&nbsp;of&nbsp;the&nbsp;service.<br>
:param&nbsp;callback:&nbsp;A&nbsp;user-defined&nbsp;callback&nbsp;function&nbsp;that&nbsp;is&nbsp;called&nbsp;when&nbsp;a&nbsp;service&nbsp;request<br>
&nbsp;&nbsp;&nbsp;&nbsp;received&nbsp;by&nbsp;the&nbsp;server.<br>
:param&nbsp;qos_profile:&nbsp;The&nbsp;quality&nbsp;of&nbsp;service&nbsp;profile&nbsp;to&nbsp;apply&nbsp;the&nbsp;service&nbsp;server.<br>
:param&nbsp;callback_group:&nbsp;The&nbsp;callback&nbsp;group&nbsp;for&nbsp;the&nbsp;service&nbsp;server.&nbsp;If&nbsp;``None``,&nbsp;then&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;nodes&nbsp;default&nbsp;callback&nbsp;group&nbsp;is&nbsp;used.</tt></dd></dl>

<dl><dt><a name="dosnode-create_subscription"><strong>create_subscription</strong></a>(self, msg_type, topic: str, callback: Callable[[~MsgType], NoneType], qos_profile: Union[rclpy.qos.QoSProfile, int], *, callback_group: Optional[rclpy.callback_groups.CallbackGroup] = None, event_callbacks: Optional[rclpy.qos_event.SubscriptionEventCallbacks] = None, qos_overriding_options: Optional[rclpy.qos_overriding_options.QoSOverridingOptions] = None, raw: bool = False) -&gt; rclpy.subscription.Subscription</dt><dd><tt>Create&nbsp;a&nbsp;new&nbsp;subscription.<br>
&nbsp;<br>
:param&nbsp;msg_type:&nbsp;The&nbsp;type&nbsp;of&nbsp;ROS&nbsp;messages&nbsp;the&nbsp;subscription&nbsp;will&nbsp;subscribe&nbsp;to.<br>
:param&nbsp;topic:&nbsp;The&nbsp;name&nbsp;of&nbsp;the&nbsp;topic&nbsp;the&nbsp;subscription&nbsp;will&nbsp;subscribe&nbsp;to.<br>
:param&nbsp;callback:&nbsp;A&nbsp;user-defined&nbsp;callback&nbsp;function&nbsp;that&nbsp;is&nbsp;called&nbsp;when&nbsp;a&nbsp;message&nbsp;is<br>
&nbsp;&nbsp;&nbsp;&nbsp;received&nbsp;by&nbsp;the&nbsp;subscription.<br>
:param&nbsp;qos_profile:&nbsp;A&nbsp;QoSProfile&nbsp;or&nbsp;a&nbsp;history&nbsp;depth&nbsp;to&nbsp;apply&nbsp;to&nbsp;the&nbsp;subscription.<br>
&nbsp;&nbsp;In&nbsp;the&nbsp;case&nbsp;that&nbsp;a&nbsp;history&nbsp;depth&nbsp;is&nbsp;provided,&nbsp;the&nbsp;QoS&nbsp;history&nbsp;is&nbsp;set&nbsp;to<br>
&nbsp;&nbsp;KEEP_LAST,&nbsp;the&nbsp;QoS&nbsp;history&nbsp;depth&nbsp;is&nbsp;set&nbsp;to&nbsp;the&nbsp;value<br>
&nbsp;&nbsp;of&nbsp;the&nbsp;parameter,&nbsp;and&nbsp;all&nbsp;other&nbsp;QoS&nbsp;settings&nbsp;are&nbsp;set&nbsp;to&nbsp;their&nbsp;default&nbsp;values.<br>
:param&nbsp;callback_group:&nbsp;The&nbsp;callback&nbsp;group&nbsp;for&nbsp;the&nbsp;subscription.&nbsp;If&nbsp;``None``,&nbsp;then&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;nodes&nbsp;default&nbsp;callback&nbsp;group&nbsp;is&nbsp;used.<br>
:param&nbsp;event_callbacks:&nbsp;User-defined&nbsp;callbacks&nbsp;for&nbsp;middleware&nbsp;events.<br>
:param&nbsp;raw:&nbsp;If&nbsp;``True``,&nbsp;then&nbsp;received&nbsp;messages&nbsp;will&nbsp;be&nbsp;stored&nbsp;in&nbsp;raw&nbsp;binary<br>
&nbsp;&nbsp;&nbsp;&nbsp;representation.</tt></dd></dl>

<dl><dt><a name="dosnode-create_timer"><strong>create_timer</strong></a>(self, timer_period_sec: float, callback: Callable, callback_group: Optional[rclpy.callback_groups.CallbackGroup] = None, clock: Optional[rclpy.clock.Clock] = None) -&gt; rclpy.timer.Timer</dt><dd><tt>Create&nbsp;a&nbsp;new&nbsp;timer.<br>
&nbsp;<br>
The&nbsp;timer&nbsp;will&nbsp;be&nbsp;started&nbsp;and&nbsp;every&nbsp;``timer_period_sec``&nbsp;number&nbsp;of&nbsp;seconds&nbsp;the&nbsp;provided<br>
callback&nbsp;function&nbsp;will&nbsp;be&nbsp;called.<br>
&nbsp;<br>
:param&nbsp;timer_period_sec:&nbsp;The&nbsp;period&nbsp;(s)&nbsp;of&nbsp;the&nbsp;timer.<br>
:param&nbsp;callback:&nbsp;A&nbsp;user-defined&nbsp;callback&nbsp;function&nbsp;that&nbsp;is&nbsp;called&nbsp;when&nbsp;the&nbsp;timer&nbsp;expires.<br>
:param&nbsp;callback_group:&nbsp;The&nbsp;callback&nbsp;group&nbsp;for&nbsp;the&nbsp;timer.&nbsp;If&nbsp;``None``,&nbsp;then&nbsp;the&nbsp;nodes<br>
&nbsp;&nbsp;&nbsp;&nbsp;default&nbsp;callback&nbsp;group&nbsp;is&nbsp;used.<br>
:param&nbsp;clock:&nbsp;The&nbsp;clock&nbsp;which&nbsp;the&nbsp;timer&nbsp;gets&nbsp;time&nbsp;from.</tt></dd></dl>

<dl><dt><a name="dosnode-declare_parameter"><strong>declare_parameter</strong></a>(self, name: str, value: Any = None, descriptor: Optional[rcl_interfaces.msg._parameter_descriptor.ParameterDescriptor] = None, ignore_override: bool = False) -&gt; rclpy.parameter.Parameter</dt><dd><tt>Declare&nbsp;and&nbsp;initialize&nbsp;a&nbsp;parameter.<br>
&nbsp;<br>
This&nbsp;method,&nbsp;if&nbsp;successful,&nbsp;will&nbsp;result&nbsp;in&nbsp;any&nbsp;callback&nbsp;registered&nbsp;with<br>
:func:`add_on_set_parameters_callback`&nbsp;to&nbsp;be&nbsp;called.<br>
&nbsp;<br>
:param&nbsp;name:&nbsp;Fully-qualified&nbsp;name&nbsp;of&nbsp;the&nbsp;parameter,&nbsp;including&nbsp;its&nbsp;namespace.<br>
:param&nbsp;value:&nbsp;Value&nbsp;of&nbsp;the&nbsp;parameter&nbsp;to&nbsp;declare.<br>
:param&nbsp;descriptor:&nbsp;Descriptor&nbsp;for&nbsp;the&nbsp;parameter&nbsp;to&nbsp;declare.<br>
:param&nbsp;ignore_override:&nbsp;True&nbsp;if&nbsp;overrides&nbsp;shall&nbsp;not&nbsp;be&nbsp;taken&nbsp;into&nbsp;account;&nbsp;False&nbsp;otherwise.<br>
:return:&nbsp;Parameter&nbsp;with&nbsp;the&nbsp;effectively&nbsp;assigned&nbsp;value.<br>
:raises:&nbsp;ParameterAlreadyDeclaredException&nbsp;if&nbsp;the&nbsp;parameter&nbsp;had&nbsp;already&nbsp;been&nbsp;declared.<br>
:raises:&nbsp;InvalidParameterException&nbsp;if&nbsp;the&nbsp;parameter&nbsp;name&nbsp;is&nbsp;invalid.<br>
:raises:&nbsp;InvalidParameterValueException&nbsp;if&nbsp;the&nbsp;registered&nbsp;callback&nbsp;rejects&nbsp;the&nbsp;parameter.</tt></dd></dl>

<dl><dt><a name="dosnode-declare_parameters"><strong>declare_parameters</strong></a>(self, namespace: str, parameters: List[Union[Tuple[str], Tuple[str, rclpy.parameter.Parameter.Type], Tuple[str, Any, rcl_interfaces.msg._parameter_descriptor.ParameterDescriptor]]], ignore_override: bool = False) -&gt; List[rclpy.parameter.Parameter]</dt><dd><tt>Declare&nbsp;a&nbsp;list&nbsp;of&nbsp;parameters.<br>
&nbsp;<br>
The&nbsp;tuples&nbsp;in&nbsp;the&nbsp;given&nbsp;parameter&nbsp;list&nbsp;shall&nbsp;contain&nbsp;the&nbsp;name&nbsp;for&nbsp;each&nbsp;parameter,<br>
optionally&nbsp;providing&nbsp;a&nbsp;value&nbsp;and&nbsp;a&nbsp;descriptor.<br>
For&nbsp;each&nbsp;entry&nbsp;in&nbsp;the&nbsp;list,&nbsp;a&nbsp;parameter&nbsp;with&nbsp;a&nbsp;name&nbsp;of&nbsp;"namespace.name"<br>
will&nbsp;be&nbsp;declared.<br>
The&nbsp;resulting&nbsp;value&nbsp;for&nbsp;each&nbsp;declared&nbsp;parameter&nbsp;will&nbsp;be&nbsp;returned,&nbsp;considering<br>
parameter&nbsp;overrides&nbsp;set&nbsp;upon&nbsp;node&nbsp;creation&nbsp;as&nbsp;the&nbsp;first&nbsp;choice,<br>
or&nbsp;provided&nbsp;parameter&nbsp;values&nbsp;as&nbsp;the&nbsp;second&nbsp;one.<br>
&nbsp;<br>
The&nbsp;name&nbsp;expansion&nbsp;is&nbsp;naive,&nbsp;so&nbsp;if&nbsp;you&nbsp;set&nbsp;the&nbsp;namespace&nbsp;to&nbsp;be&nbsp;"foo.",<br>
then&nbsp;the&nbsp;resulting&nbsp;parameter&nbsp;names&nbsp;will&nbsp;be&nbsp;like&nbsp;"foo..name".<br>
However,&nbsp;if&nbsp;the&nbsp;namespace&nbsp;is&nbsp;an&nbsp;empty&nbsp;string,&nbsp;then&nbsp;no&nbsp;leading&nbsp;'.'&nbsp;will&nbsp;be<br>
placed&nbsp;before&nbsp;each&nbsp;name,&nbsp;which&nbsp;would&nbsp;have&nbsp;been&nbsp;the&nbsp;case&nbsp;when&nbsp;naively<br>
expanding&nbsp;"namespace.name".<br>
This&nbsp;allows&nbsp;you&nbsp;to&nbsp;declare&nbsp;several&nbsp;parameters&nbsp;at&nbsp;once&nbsp;without&nbsp;a&nbsp;namespace.<br>
&nbsp;<br>
This&nbsp;method,&nbsp;if&nbsp;successful,&nbsp;will&nbsp;result&nbsp;in&nbsp;any&nbsp;callback&nbsp;registered&nbsp;with<br>
:func:`add_on_set_parameters_callback`&nbsp;to&nbsp;be&nbsp;called&nbsp;once&nbsp;for&nbsp;each&nbsp;parameter.<br>
If&nbsp;one&nbsp;of&nbsp;those&nbsp;calls&nbsp;fail,&nbsp;an&nbsp;exception&nbsp;will&nbsp;be&nbsp;raised&nbsp;and&nbsp;the&nbsp;remaining&nbsp;parameters&nbsp;will<br>
not&nbsp;be&nbsp;declared.<br>
Parameters&nbsp;declared&nbsp;up&nbsp;to&nbsp;that&nbsp;point&nbsp;will&nbsp;not&nbsp;be&nbsp;undeclared.<br>
&nbsp;<br>
:param&nbsp;namespace:&nbsp;Namespace&nbsp;for&nbsp;parameters.<br>
:param&nbsp;parameters:&nbsp;List&nbsp;of&nbsp;tuples&nbsp;with&nbsp;parameters&nbsp;to&nbsp;declare.<br>
:param&nbsp;ignore_override:&nbsp;True&nbsp;if&nbsp;overrides&nbsp;shall&nbsp;not&nbsp;be&nbsp;taken&nbsp;into&nbsp;account;&nbsp;False&nbsp;otherwise.<br>
:return:&nbsp;Parameter&nbsp;list&nbsp;with&nbsp;the&nbsp;effectively&nbsp;assigned&nbsp;values&nbsp;for&nbsp;each&nbsp;of&nbsp;them.<br>
:raises:&nbsp;ParameterAlreadyDeclaredException&nbsp;if&nbsp;the&nbsp;parameter&nbsp;had&nbsp;already&nbsp;been&nbsp;declared.<br>
:raises:&nbsp;InvalidParameterException&nbsp;if&nbsp;the&nbsp;parameter&nbsp;name&nbsp;is&nbsp;invalid.<br>
:raises:&nbsp;InvalidParameterValueException&nbsp;if&nbsp;the&nbsp;registered&nbsp;callback&nbsp;rejects&nbsp;any&nbsp;parameter.<br>
:raises:&nbsp;TypeError&nbsp;if&nbsp;any&nbsp;tuple&nbsp;in&nbsp;**parameters**&nbsp;does&nbsp;not&nbsp;match&nbsp;the&nbsp;annotated&nbsp;type.</tt></dd></dl>

<dl><dt><a name="dosnode-describe_parameter"><strong>describe_parameter</strong></a>(self, name: str) -&gt; rcl_interfaces.msg._parameter_descriptor.ParameterDescriptor</dt><dd><tt>Get&nbsp;the&nbsp;parameter&nbsp;descriptor&nbsp;of&nbsp;a&nbsp;given&nbsp;parameter.<br>
&nbsp;<br>
:param&nbsp;name:&nbsp;Fully-qualified&nbsp;name&nbsp;of&nbsp;the&nbsp;parameter,&nbsp;including&nbsp;its&nbsp;namespace.<br>
:return:&nbsp;ParameterDescriptor&nbsp;corresponding&nbsp;to&nbsp;the&nbsp;parameter,<br>
&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;default&nbsp;ParameterDescriptor&nbsp;if&nbsp;parameter&nbsp;had&nbsp;not&nbsp;been&nbsp;declared&nbsp;before<br>
&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;undeclared&nbsp;parameters&nbsp;are&nbsp;allowed.<br>
:raises:&nbsp;ParameterNotDeclaredException&nbsp;if&nbsp;parameter&nbsp;had&nbsp;not&nbsp;been&nbsp;declared&nbsp;before<br>
&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;undeclared&nbsp;parameters&nbsp;are&nbsp;not&nbsp;allowed.</tt></dd></dl>

<dl><dt><a name="dosnode-describe_parameters"><strong>describe_parameters</strong></a>(self, names: List[str]) -&gt; List[rcl_interfaces.msg._parameter_descriptor.ParameterDescriptor]</dt><dd><tt>Get&nbsp;the&nbsp;parameter&nbsp;descriptors&nbsp;of&nbsp;a&nbsp;given&nbsp;list&nbsp;of&nbsp;parameters.<br>
&nbsp;<br>
:param&nbsp;name:&nbsp;List&nbsp;of&nbsp;fully-qualified&nbsp;names&nbsp;of&nbsp;the&nbsp;parameters&nbsp;to&nbsp;describe.<br>
:return:&nbsp;List&nbsp;of&nbsp;ParameterDescriptors&nbsp;corresponding&nbsp;to&nbsp;the&nbsp;given&nbsp;parameters.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Default&nbsp;ParameterDescriptors&nbsp;shall&nbsp;be&nbsp;returned&nbsp;for&nbsp;parameters&nbsp;that<br>
&nbsp;&nbsp;&nbsp;&nbsp;had&nbsp;not&nbsp;been&nbsp;declared&nbsp;before&nbsp;if&nbsp;undeclared&nbsp;parameters&nbsp;are&nbsp;allowed.<br>
:raises:&nbsp;ParameterNotDeclaredException&nbsp;if&nbsp;at&nbsp;least&nbsp;one&nbsp;parameter<br>
&nbsp;&nbsp;&nbsp;&nbsp;had&nbsp;not&nbsp;been&nbsp;declared&nbsp;before&nbsp;and&nbsp;undeclared&nbsp;parameters&nbsp;are&nbsp;not&nbsp;allowed.</tt></dd></dl>

<dl><dt><a name="dosnode-destroy_client"><strong>destroy_client</strong></a>(self, client: rclpy.client.Client) -&gt; bool</dt><dd><tt>Destroy&nbsp;a&nbsp;service&nbsp;client&nbsp;created&nbsp;by&nbsp;the&nbsp;node.<br>
&nbsp;<br>
:return:&nbsp;``True``&nbsp;if&nbsp;successful,&nbsp;``False``&nbsp;otherwise.</tt></dd></dl>

<dl><dt><a name="dosnode-destroy_guard_condition"><strong>destroy_guard_condition</strong></a>(self, guard: rclpy.guard_condition.GuardCondition) -&gt; bool</dt><dd><tt>Destroy&nbsp;a&nbsp;guard&nbsp;condition&nbsp;created&nbsp;by&nbsp;the&nbsp;node.<br>
&nbsp;<br>
:return:&nbsp;``True``&nbsp;if&nbsp;successful,&nbsp;``False``&nbsp;otherwise.</tt></dd></dl>

<dl><dt><a name="dosnode-destroy_node"><strong>destroy_node</strong></a>(self)</dt><dd><tt>Destroy&nbsp;the&nbsp;node.<br>
&nbsp;<br>
Frees&nbsp;resources&nbsp;used&nbsp;by&nbsp;the&nbsp;node,&nbsp;including&nbsp;any&nbsp;entities&nbsp;created&nbsp;by&nbsp;the&nbsp;following&nbsp;methods:<br>
&nbsp;<br>
*&nbsp;:func:`create_publisher`<br>
*&nbsp;:func:`create_subscription`<br>
*&nbsp;:func:`create_client`<br>
*&nbsp;:func:`create_service`<br>
*&nbsp;:func:`create_timer`<br>
*&nbsp;:func:`create_guard_condition`</tt></dd></dl>

<dl><dt><a name="dosnode-destroy_publisher"><strong>destroy_publisher</strong></a>(self, publisher: rclpy.publisher.Publisher) -&gt; bool</dt><dd><tt>Destroy&nbsp;a&nbsp;publisher&nbsp;created&nbsp;by&nbsp;the&nbsp;node.<br>
&nbsp;<br>
:return:&nbsp;``True``&nbsp;if&nbsp;successful,&nbsp;``False``&nbsp;otherwise.</tt></dd></dl>

<dl><dt><a name="dosnode-destroy_rate"><strong>destroy_rate</strong></a>(self, rate: rclpy.timer.Rate) -&gt; bool</dt><dd><tt>Destroy&nbsp;a&nbsp;Rate&nbsp;object&nbsp;created&nbsp;by&nbsp;the&nbsp;node.<br>
&nbsp;<br>
:return:&nbsp;``True``&nbsp;if&nbsp;successful,&nbsp;``False``&nbsp;otherwise.</tt></dd></dl>

<dl><dt><a name="dosnode-destroy_service"><strong>destroy_service</strong></a>(self, service: rclpy.service.Service) -&gt; bool</dt><dd><tt>Destroy&nbsp;a&nbsp;service&nbsp;server&nbsp;created&nbsp;by&nbsp;the&nbsp;node.<br>
&nbsp;<br>
:return:&nbsp;``True``&nbsp;if&nbsp;successful,&nbsp;``False``&nbsp;otherwise.</tt></dd></dl>

<dl><dt><a name="dosnode-destroy_subscription"><strong>destroy_subscription</strong></a>(self, subscription: rclpy.subscription.Subscription) -&gt; bool</dt><dd><tt>Destroy&nbsp;a&nbsp;subscription&nbsp;created&nbsp;by&nbsp;the&nbsp;node.<br>
&nbsp;<br>
:return:&nbsp;``True``&nbsp;if&nbsp;succesful,&nbsp;``False``&nbsp;otherwise.</tt></dd></dl>

<dl><dt><a name="dosnode-destroy_timer"><strong>destroy_timer</strong></a>(self, timer: rclpy.timer.Timer) -&gt; bool</dt><dd><tt>Destroy&nbsp;a&nbsp;timer&nbsp;created&nbsp;by&nbsp;the&nbsp;node.<br>
&nbsp;<br>
:return:&nbsp;``True``&nbsp;if&nbsp;successful,&nbsp;``False``&nbsp;otherwise.</tt></dd></dl>

<dl><dt><a name="dosnode-get_client_names_and_types_by_node"><strong>get_client_names_and_types_by_node</strong></a>(self, node_name: str, node_namespace: str) -&gt; List[Tuple[str, List[str]]]</dt><dd><tt>Get&nbsp;a&nbsp;list&nbsp;of&nbsp;discovered&nbsp;service&nbsp;client&nbsp;topics&nbsp;for&nbsp;a&nbsp;remote&nbsp;node.<br>
&nbsp;<br>
:param&nbsp;node_name:&nbsp;Name&nbsp;of&nbsp;a&nbsp;remote&nbsp;node&nbsp;to&nbsp;get&nbsp;service&nbsp;clients&nbsp;for.<br>
:param&nbsp;node_namespace:&nbsp;Namespace&nbsp;of&nbsp;the&nbsp;remote&nbsp;node.<br>
:return:&nbsp;List&nbsp;of&nbsp;tuples.<br>
&nbsp;&nbsp;The&nbsp;fist&nbsp;element&nbsp;of&nbsp;each&nbsp;tuple&nbsp;is&nbsp;the&nbsp;service&nbsp;client&nbsp;name<br>
&nbsp;&nbsp;and&nbsp;the&nbsp;second&nbsp;element&nbsp;is&nbsp;a&nbsp;list&nbsp;of&nbsp;service&nbsp;client&nbsp;types.<br>
:raise&nbsp;NodeNameNonExistentError:&nbsp;If&nbsp;the&nbsp;node&nbsp;wasn't&nbsp;found.<br>
:raise&nbsp;RuntimeError:&nbsp;Unexpected&nbsp;failure.</tt></dd></dl>

<dl><dt><a name="dosnode-get_clock"><strong>get_clock</strong></a>(self) -&gt; rclpy.clock.Clock</dt><dd><tt>Get&nbsp;the&nbsp;clock&nbsp;used&nbsp;by&nbsp;the&nbsp;node.</tt></dd></dl>

<dl><dt><a name="dosnode-get_fully_qualified_name"><strong>get_fully_qualified_name</strong></a>(self) -&gt; str</dt><dd><tt>Get&nbsp;the&nbsp;node's&nbsp;fully&nbsp;qualified&nbsp;name.<br>
&nbsp;<br>
:return:&nbsp;Fully&nbsp;qualified&nbsp;node&nbsp;name.</tt></dd></dl>

<dl><dt><a name="dosnode-get_logger"><strong>get_logger</strong></a>(self)</dt><dd><tt>Get&nbsp;the&nbsp;nodes&nbsp;logger.</tt></dd></dl>

<dl><dt><a name="dosnode-get_name"><strong>get_name</strong></a>(self) -&gt; str</dt><dd><tt>Get&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;node.</tt></dd></dl>

<dl><dt><a name="dosnode-get_namespace"><strong>get_namespace</strong></a>(self) -&gt; str</dt><dd><tt>Get&nbsp;the&nbsp;namespace&nbsp;of&nbsp;the&nbsp;node.</tt></dd></dl>

<dl><dt><a name="dosnode-get_node_names"><strong>get_node_names</strong></a>(self) -&gt; List[str]</dt><dd><tt>Get&nbsp;a&nbsp;list&nbsp;of&nbsp;names&nbsp;for&nbsp;discovered&nbsp;nodes.<br>
&nbsp;<br>
:return:&nbsp;List&nbsp;of&nbsp;node&nbsp;names.</tt></dd></dl>

<dl><dt><a name="dosnode-get_node_names_and_namespaces"><strong>get_node_names_and_namespaces</strong></a>(self) -&gt; List[Tuple[str, str]]</dt><dd><tt>Get&nbsp;a&nbsp;list&nbsp;of&nbsp;names&nbsp;and&nbsp;namespaces&nbsp;for&nbsp;discovered&nbsp;nodes.<br>
&nbsp;<br>
:return:&nbsp;List&nbsp;of&nbsp;tuples&nbsp;containing&nbsp;two&nbsp;strings:&nbsp;the&nbsp;node&nbsp;name&nbsp;and&nbsp;node&nbsp;namespace.</tt></dd></dl>

<dl><dt><a name="dosnode-get_node_names_and_namespaces_with_enclaves"><strong>get_node_names_and_namespaces_with_enclaves</strong></a>(self) -&gt; List[Tuple[str, str, str]]</dt><dd><tt>Get&nbsp;a&nbsp;list&nbsp;of&nbsp;names,&nbsp;namespaces&nbsp;and&nbsp;enclaves&nbsp;for&nbsp;discovered&nbsp;nodes.<br>
&nbsp;<br>
:return:&nbsp;List&nbsp;of&nbsp;tuples&nbsp;containing&nbsp;three&nbsp;strings:&nbsp;the&nbsp;node&nbsp;name,&nbsp;node&nbsp;namespace<br>
&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;enclave.</tt></dd></dl>

<dl><dt><a name="dosnode-get_parameter"><strong>get_parameter</strong></a>(self, name: str) -&gt; rclpy.parameter.Parameter</dt><dd><tt>Get&nbsp;a&nbsp;parameter&nbsp;by&nbsp;name.<br>
&nbsp;<br>
:param&nbsp;name:&nbsp;Fully-qualified&nbsp;name&nbsp;of&nbsp;the&nbsp;parameter,&nbsp;including&nbsp;its&nbsp;namespace.<br>
:return:&nbsp;The&nbsp;value&nbsp;for&nbsp;the&nbsp;given&nbsp;parameter&nbsp;name.<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;default&nbsp;Parameter&nbsp;will&nbsp;be&nbsp;returned&nbsp;for&nbsp;an&nbsp;undeclared&nbsp;parameter&nbsp;if<br>
&nbsp;&nbsp;&nbsp;&nbsp;undeclared&nbsp;parameters&nbsp;are&nbsp;allowed.<br>
:raises:&nbsp;ParameterNotDeclaredException&nbsp;if&nbsp;undeclared&nbsp;parameters&nbsp;are&nbsp;not&nbsp;allowed,<br>
&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;the&nbsp;parameter&nbsp;hadn't&nbsp;been&nbsp;declared&nbsp;beforehand.<br>
:raises:&nbsp;ParameterUninitializedException&nbsp;if&nbsp;the&nbsp;parameter&nbsp;is&nbsp;statically&nbsp;typed&nbsp;and<br>
&nbsp;&nbsp;&nbsp;&nbsp;uninitialized.</tt></dd></dl>

<dl><dt><a name="dosnode-get_parameter_or"><strong>get_parameter_or</strong></a>(self, name: str, alternative_value: Optional[rclpy.parameter.Parameter] = None) -&gt; rclpy.parameter.Parameter</dt><dd><tt>Get&nbsp;a&nbsp;parameter&nbsp;or&nbsp;the&nbsp;alternative&nbsp;value.<br>
&nbsp;<br>
If&nbsp;the&nbsp;alternative&nbsp;value&nbsp;is&nbsp;None,&nbsp;a&nbsp;default&nbsp;Parameter&nbsp;with&nbsp;the&nbsp;given&nbsp;name&nbsp;and&nbsp;NOT_SET<br>
type&nbsp;will&nbsp;be&nbsp;returned&nbsp;if&nbsp;the&nbsp;parameter&nbsp;was&nbsp;not&nbsp;declared.<br>
&nbsp;<br>
:param&nbsp;name:&nbsp;Fully-qualified&nbsp;name&nbsp;of&nbsp;the&nbsp;parameter,&nbsp;including&nbsp;its&nbsp;namespace.<br>
:param&nbsp;alternative_value:&nbsp;Alternative&nbsp;parameter&nbsp;to&nbsp;get&nbsp;if&nbsp;it&nbsp;had&nbsp;not&nbsp;been&nbsp;declared&nbsp;before.<br>
:return:&nbsp;Requested&nbsp;parameter,&nbsp;or&nbsp;alternative&nbsp;value&nbsp;if&nbsp;it&nbsp;hadn't&nbsp;been&nbsp;declared&nbsp;before&nbsp;or&nbsp;is<br>
&nbsp;&nbsp;an&nbsp;uninitialized&nbsp;statically&nbsp;typed&nbsp;parameter.</tt></dd></dl>

<dl><dt><a name="dosnode-get_parameter_type"><strong>get_parameter_type</strong></a>(self, name: str) -&gt; rclpy.parameter.Parameter.Type</dt><dd><tt>Get&nbsp;a&nbsp;parameter&nbsp;type&nbsp;by&nbsp;name.<br>
&nbsp;<br>
:param&nbsp;name:&nbsp;Fully-qualified&nbsp;name&nbsp;of&nbsp;the&nbsp;parameter,&nbsp;including&nbsp;its&nbsp;namespace.<br>
:return:&nbsp;The&nbsp;type&nbsp;for&nbsp;the&nbsp;given&nbsp;parameter&nbsp;name.<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;default&nbsp;Parameter.Type.NOT_SET&nbsp;will&nbsp;be&nbsp;returned&nbsp;for&nbsp;an&nbsp;undeclared&nbsp;parameter<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;undeclared&nbsp;parameters&nbsp;are&nbsp;allowed.<br>
:raises:&nbsp;ParameterNotDeclaredException&nbsp;if&nbsp;undeclared&nbsp;parameters&nbsp;are&nbsp;not&nbsp;allowed,<br>
&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;the&nbsp;parameter&nbsp;hadn't&nbsp;been&nbsp;declared&nbsp;beforehand.</tt></dd></dl>

<dl><dt><a name="dosnode-get_parameter_types"><strong>get_parameter_types</strong></a>(self, names: List[str]) -&gt; List[rclpy.parameter.Parameter.Type]</dt><dd><tt>Get&nbsp;a&nbsp;list&nbsp;of&nbsp;parameter&nbsp;types.<br>
&nbsp;<br>
:param&nbsp;names:&nbsp;Fully-qualified&nbsp;names&nbsp;of&nbsp;the&nbsp;parameters&nbsp;to&nbsp;get,&nbsp;including&nbsp;their&nbsp;namespaces.<br>
:return:&nbsp;The&nbsp;values&nbsp;for&nbsp;the&nbsp;given&nbsp;parameter&nbsp;types.<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;default&nbsp;Parameter.Type.NOT_SET&nbsp;will&nbsp;be&nbsp;returned&nbsp;for&nbsp;undeclared&nbsp;parameters<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;undeclared&nbsp;parameters&nbsp;are&nbsp;allowed.<br>
:raises:&nbsp;ParameterNotDeclaredException&nbsp;if&nbsp;undeclared&nbsp;parameters&nbsp;are&nbsp;not&nbsp;allowed,<br>
&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;at&nbsp;least&nbsp;one&nbsp;parameter&nbsp;hadn't&nbsp;been&nbsp;declared&nbsp;beforehand.</tt></dd></dl>

<dl><dt><a name="dosnode-get_parameters"><strong>get_parameters</strong></a>(self, names: List[str]) -&gt; List[rclpy.parameter.Parameter]</dt><dd><tt>Get&nbsp;a&nbsp;list&nbsp;of&nbsp;parameters.<br>
&nbsp;<br>
:param&nbsp;names:&nbsp;Fully-qualified&nbsp;names&nbsp;of&nbsp;the&nbsp;parameters&nbsp;to&nbsp;get,&nbsp;including&nbsp;their&nbsp;namespaces.<br>
:return:&nbsp;The&nbsp;values&nbsp;for&nbsp;the&nbsp;given&nbsp;parameter&nbsp;names.<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;default&nbsp;Parameter&nbsp;will&nbsp;be&nbsp;returned&nbsp;for&nbsp;undeclared&nbsp;parameters&nbsp;if<br>
&nbsp;&nbsp;&nbsp;&nbsp;undeclared&nbsp;parameters&nbsp;are&nbsp;allowed.<br>
:raises:&nbsp;ParameterNotDeclaredException&nbsp;if&nbsp;undeclared&nbsp;parameters&nbsp;are&nbsp;not&nbsp;allowed,<br>
&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;at&nbsp;least&nbsp;one&nbsp;parameter&nbsp;hadn't&nbsp;been&nbsp;declared&nbsp;beforehand.<br>
:raises:&nbsp;ParameterUninitializedException&nbsp;if&nbsp;at&nbsp;least&nbsp;one&nbsp;parameter&nbsp;is&nbsp;statically&nbsp;typed&nbsp;and<br>
&nbsp;&nbsp;&nbsp;&nbsp;uninitialized.</tt></dd></dl>

<dl><dt><a name="dosnode-get_parameters_by_prefix"><strong>get_parameters_by_prefix</strong></a>(self, prefix: str) -&gt; Dict[str, Union[bool, int, float, str, bytes, Sequence[bool], Sequence[int], Sequence[float], Sequence[str], NoneType]]</dt><dd><tt>Get&nbsp;parameters&nbsp;that&nbsp;have&nbsp;a&nbsp;given&nbsp;prefix&nbsp;in&nbsp;their&nbsp;names&nbsp;as&nbsp;a&nbsp;dictionary.<br>
&nbsp;<br>
The&nbsp;names&nbsp;which&nbsp;are&nbsp;used&nbsp;as&nbsp;keys&nbsp;in&nbsp;the&nbsp;returned&nbsp;dictionary&nbsp;have&nbsp;the&nbsp;prefix&nbsp;removed.<br>
For&nbsp;example,&nbsp;if&nbsp;you&nbsp;use&nbsp;the&nbsp;prefix&nbsp;"foo"&nbsp;and&nbsp;the&nbsp;parameters&nbsp;"foo.ping",&nbsp;"foo.pong"<br>
and&nbsp;"bar.baz"&nbsp;exist,&nbsp;then&nbsp;the&nbsp;returned&nbsp;dictionary&nbsp;will&nbsp;have&nbsp;the&nbsp;keys&nbsp;"ping"&nbsp;and&nbsp;"pong".<br>
Note&nbsp;that&nbsp;the&nbsp;parameter&nbsp;separator&nbsp;is&nbsp;also&nbsp;removed&nbsp;from&nbsp;the&nbsp;parameter&nbsp;name&nbsp;to&nbsp;create&nbsp;the<br>
keys.<br>
&nbsp;<br>
An&nbsp;empty&nbsp;string&nbsp;for&nbsp;the&nbsp;prefix&nbsp;will&nbsp;match&nbsp;all&nbsp;parameters.<br>
&nbsp;<br>
If&nbsp;no&nbsp;parameters&nbsp;with&nbsp;the&nbsp;prefix&nbsp;are&nbsp;found,&nbsp;an&nbsp;empty&nbsp;dictionary&nbsp;will&nbsp;be&nbsp;returned.<br>
&nbsp;<br>
:param&nbsp;prefix:&nbsp;The&nbsp;prefix&nbsp;of&nbsp;the&nbsp;parameters&nbsp;to&nbsp;get.<br>
:return:&nbsp;Dict&nbsp;of&nbsp;parameters&nbsp;with&nbsp;the&nbsp;given&nbsp;prefix.</tt></dd></dl>

<dl><dt><a name="dosnode-get_publisher_names_and_types_by_node"><strong>get_publisher_names_and_types_by_node</strong></a>(self, node_name: str, node_namespace: str, no_demangle: bool = False) -&gt; List[Tuple[str, List[str]]]</dt><dd><tt>Get&nbsp;a&nbsp;list&nbsp;of&nbsp;discovered&nbsp;topics&nbsp;for&nbsp;publishers&nbsp;of&nbsp;a&nbsp;remote&nbsp;node.<br>
&nbsp;<br>
:param&nbsp;node_name:&nbsp;Name&nbsp;of&nbsp;a&nbsp;remote&nbsp;node&nbsp;to&nbsp;get&nbsp;publishers&nbsp;for.<br>
:param&nbsp;node_namespace:&nbsp;Namespace&nbsp;of&nbsp;the&nbsp;remote&nbsp;node.<br>
:param&nbsp;no_demangle:&nbsp;If&nbsp;``True``,&nbsp;then&nbsp;topic&nbsp;names&nbsp;and&nbsp;types&nbsp;returned&nbsp;will&nbsp;not&nbsp;be&nbsp;demangled.<br>
:return:&nbsp;List&nbsp;of&nbsp;tuples.<br>
&nbsp;&nbsp;The&nbsp;first&nbsp;element&nbsp;of&nbsp;each&nbsp;tuple&nbsp;is&nbsp;the&nbsp;topic&nbsp;name&nbsp;and&nbsp;the&nbsp;second&nbsp;element&nbsp;is&nbsp;a&nbsp;list&nbsp;of<br>
&nbsp;&nbsp;topic&nbsp;types.<br>
:raise&nbsp;NodeNameNonExistentError:&nbsp;If&nbsp;the&nbsp;node&nbsp;wasn't&nbsp;found.<br>
:raise&nbsp;RuntimeError:&nbsp;Unexpected&nbsp;failure.</tt></dd></dl>

<dl><dt><a name="dosnode-get_publishers_info_by_topic"><strong>get_publishers_info_by_topic</strong></a>(self, topic_name: str, no_mangle: bool = False) -&gt; List[rclpy.topic_endpoint_info.TopicEndpointInfo]</dt><dd><tt>Return&nbsp;a&nbsp;list&nbsp;of&nbsp;publishers&nbsp;on&nbsp;a&nbsp;given&nbsp;topic.<br>
&nbsp;<br>
The&nbsp;returned&nbsp;parameter&nbsp;is&nbsp;a&nbsp;list&nbsp;of&nbsp;TopicEndpointInfo&nbsp;objects,&nbsp;where&nbsp;each&nbsp;will&nbsp;contain<br>
the&nbsp;node&nbsp;name,&nbsp;node&nbsp;namespace,&nbsp;topic&nbsp;type,&nbsp;topic&nbsp;endpoint's&nbsp;GID,&nbsp;and&nbsp;its&nbsp;QoS&nbsp;profile.<br>
&nbsp;<br>
When&nbsp;the&nbsp;`no_mangle`&nbsp;parameter&nbsp;is&nbsp;`true`,&nbsp;the&nbsp;provided&nbsp;`topic_name`&nbsp;should&nbsp;be&nbsp;a&nbsp;valid&nbsp;topic<br>
name&nbsp;for&nbsp;the&nbsp;middleware&nbsp;(useful&nbsp;when&nbsp;combining&nbsp;ROS&nbsp;with&nbsp;native&nbsp;middleware&nbsp;(e.g.&nbsp;DDS)&nbsp;apps).<br>
When&nbsp;the&nbsp;`no_mangle`&nbsp;parameter&nbsp;is&nbsp;`false`,&nbsp;the&nbsp;provided&nbsp;`topic_name`&nbsp;should&nbsp;follow<br>
ROS&nbsp;topic&nbsp;name&nbsp;conventions.<br>
&nbsp;<br>
`topic_name`&nbsp;may&nbsp;be&nbsp;a&nbsp;relative,&nbsp;private,&nbsp;or&nbsp;fully&nbsp;qualified&nbsp;topic&nbsp;name.<br>
A&nbsp;relative&nbsp;or&nbsp;private&nbsp;topic&nbsp;will&nbsp;be&nbsp;expanded&nbsp;using&nbsp;this&nbsp;node's&nbsp;namespace&nbsp;and&nbsp;name.<br>
The&nbsp;queried&nbsp;`topic_name`&nbsp;is&nbsp;not&nbsp;remapped.<br>
&nbsp;<br>
:param&nbsp;topic_name:&nbsp;the&nbsp;topic_name&nbsp;on&nbsp;which&nbsp;to&nbsp;find&nbsp;the&nbsp;publishers.<br>
:param&nbsp;no_mangle:&nbsp;no_mangle&nbsp;if&nbsp;`true`,&nbsp;`topic_name`&nbsp;needs&nbsp;to&nbsp;be&nbsp;a&nbsp;valid&nbsp;middleware&nbsp;topic<br>
&nbsp;&nbsp;&nbsp;&nbsp;name,&nbsp;otherwise&nbsp;it&nbsp;should&nbsp;be&nbsp;a&nbsp;valid&nbsp;ROS&nbsp;topic&nbsp;name.&nbsp;Defaults&nbsp;to&nbsp;`false`.<br>
:return:&nbsp;a&nbsp;list&nbsp;of&nbsp;TopicEndpointInfo&nbsp;for&nbsp;all&nbsp;the&nbsp;publishers&nbsp;on&nbsp;this&nbsp;topic.</tt></dd></dl>

<dl><dt><a name="dosnode-get_service_names_and_types"><strong>get_service_names_and_types</strong></a>(self) -&gt; List[Tuple[str, List[str]]]</dt><dd><tt>Get&nbsp;a&nbsp;list&nbsp;of&nbsp;service&nbsp;topics&nbsp;for&nbsp;the&nbsp;node.<br>
&nbsp;<br>
:return:&nbsp;List&nbsp;of&nbsp;tuples.<br>
&nbsp;&nbsp;The&nbsp;first&nbsp;element&nbsp;of&nbsp;each&nbsp;tuple&nbsp;is&nbsp;the&nbsp;service&nbsp;name&nbsp;and&nbsp;the&nbsp;second&nbsp;element&nbsp;is&nbsp;a&nbsp;list&nbsp;of<br>
&nbsp;&nbsp;service&nbsp;types.</tt></dd></dl>

<dl><dt><a name="dosnode-get_service_names_and_types_by_node"><strong>get_service_names_and_types_by_node</strong></a>(self, node_name: str, node_namespace: str) -&gt; List[Tuple[str, List[str]]]</dt><dd><tt>Get&nbsp;a&nbsp;list&nbsp;of&nbsp;discovered&nbsp;service&nbsp;server&nbsp;topics&nbsp;for&nbsp;a&nbsp;remote&nbsp;node.<br>
&nbsp;<br>
:param&nbsp;node_name:&nbsp;Name&nbsp;of&nbsp;a&nbsp;remote&nbsp;node&nbsp;to&nbsp;get&nbsp;services&nbsp;for.<br>
:param&nbsp;node_namespace:&nbsp;Namespace&nbsp;of&nbsp;the&nbsp;remote&nbsp;node.<br>
:return:&nbsp;List&nbsp;of&nbsp;tuples.<br>
&nbsp;&nbsp;The&nbsp;first&nbsp;element&nbsp;of&nbsp;each&nbsp;tuple&nbsp;is&nbsp;the&nbsp;service&nbsp;server&nbsp;name<br>
&nbsp;&nbsp;and&nbsp;the&nbsp;second&nbsp;element&nbsp;is&nbsp;a&nbsp;list&nbsp;of&nbsp;service&nbsp;types.<br>
:raise&nbsp;NodeNameNonExistentError:&nbsp;If&nbsp;the&nbsp;node&nbsp;wasn't&nbsp;found.<br>
:raise&nbsp;RuntimeError:&nbsp;Unexpected&nbsp;failure.</tt></dd></dl>

<dl><dt><a name="dosnode-get_subscriber_names_and_types_by_node"><strong>get_subscriber_names_and_types_by_node</strong></a>(self, node_name: str, node_namespace: str, no_demangle: bool = False) -&gt; List[Tuple[str, List[str]]]</dt><dd><tt>Get&nbsp;a&nbsp;list&nbsp;of&nbsp;discovered&nbsp;topics&nbsp;for&nbsp;subscriptions&nbsp;of&nbsp;a&nbsp;remote&nbsp;node.<br>
&nbsp;<br>
:param&nbsp;node_name:&nbsp;Name&nbsp;of&nbsp;a&nbsp;remote&nbsp;node&nbsp;to&nbsp;get&nbsp;subscriptions&nbsp;for.<br>
:param&nbsp;node_namespace:&nbsp;Namespace&nbsp;of&nbsp;the&nbsp;remote&nbsp;node.<br>
:param&nbsp;no_demangle:&nbsp;If&nbsp;``True``,&nbsp;then&nbsp;topic&nbsp;names&nbsp;and&nbsp;types&nbsp;returned&nbsp;will&nbsp;not&nbsp;be&nbsp;demangled.<br>
:return:&nbsp;List&nbsp;of&nbsp;tuples.<br>
&nbsp;&nbsp;The&nbsp;first&nbsp;element&nbsp;of&nbsp;each&nbsp;tuple&nbsp;is&nbsp;the&nbsp;topic&nbsp;name&nbsp;and&nbsp;the&nbsp;second&nbsp;element&nbsp;is&nbsp;a&nbsp;list&nbsp;of<br>
&nbsp;&nbsp;topic&nbsp;types.<br>
:raise&nbsp;NodeNameNonExistentError:&nbsp;If&nbsp;the&nbsp;node&nbsp;wasn't&nbsp;found.<br>
:raise&nbsp;RuntimeError:&nbsp;Unexpected&nbsp;failure.</tt></dd></dl>

<dl><dt><a name="dosnode-get_subscriptions_info_by_topic"><strong>get_subscriptions_info_by_topic</strong></a>(self, topic_name: str, no_mangle: bool = False) -&gt; List[rclpy.topic_endpoint_info.TopicEndpointInfo]</dt><dd><tt>Return&nbsp;a&nbsp;list&nbsp;of&nbsp;subscriptions&nbsp;on&nbsp;a&nbsp;given&nbsp;topic.<br>
&nbsp;<br>
The&nbsp;returned&nbsp;parameter&nbsp;is&nbsp;a&nbsp;list&nbsp;of&nbsp;TopicEndpointInfo&nbsp;objects,&nbsp;where&nbsp;each&nbsp;will&nbsp;contain<br>
the&nbsp;node&nbsp;name,&nbsp;node&nbsp;namespace,&nbsp;topic&nbsp;type,&nbsp;topic&nbsp;endpoint's&nbsp;GID,&nbsp;and&nbsp;its&nbsp;QoS&nbsp;profile.<br>
&nbsp;<br>
When&nbsp;the&nbsp;`no_mangle`&nbsp;parameter&nbsp;is&nbsp;`true`,&nbsp;the&nbsp;provided&nbsp;`topic_name`&nbsp;should&nbsp;be&nbsp;a&nbsp;valid&nbsp;topic<br>
name&nbsp;for&nbsp;the&nbsp;middleware&nbsp;(useful&nbsp;when&nbsp;combining&nbsp;ROS&nbsp;with&nbsp;native&nbsp;middleware&nbsp;(e.g.&nbsp;DDS)&nbsp;apps).<br>
When&nbsp;the&nbsp;`no_mangle`&nbsp;parameter&nbsp;is&nbsp;`false`,&nbsp;the&nbsp;provided&nbsp;`topic_name`&nbsp;should&nbsp;follow<br>
ROS&nbsp;topic&nbsp;name&nbsp;conventions.<br>
&nbsp;<br>
`topic_name`&nbsp;may&nbsp;be&nbsp;a&nbsp;relative,&nbsp;private,&nbsp;or&nbsp;fully&nbsp;qualified&nbsp;topic&nbsp;name.<br>
A&nbsp;relative&nbsp;or&nbsp;private&nbsp;topic&nbsp;will&nbsp;be&nbsp;expanded&nbsp;using&nbsp;this&nbsp;node's&nbsp;namespace&nbsp;and&nbsp;name.<br>
The&nbsp;queried&nbsp;`topic_name`&nbsp;is&nbsp;not&nbsp;remapped.<br>
&nbsp;<br>
:param&nbsp;topic_name:&nbsp;the&nbsp;topic_name&nbsp;on&nbsp;which&nbsp;to&nbsp;find&nbsp;the&nbsp;subscriptions.<br>
:param&nbsp;no_mangle:&nbsp;no_mangle&nbsp;if&nbsp;`true`,&nbsp;`topic_name`&nbsp;needs&nbsp;to&nbsp;be&nbsp;a&nbsp;valid&nbsp;middleware&nbsp;topic<br>
&nbsp;&nbsp;&nbsp;&nbsp;name,&nbsp;otherwise&nbsp;it&nbsp;should&nbsp;be&nbsp;a&nbsp;valid&nbsp;ROS&nbsp;topic&nbsp;name.&nbsp;Defaults&nbsp;to&nbsp;`false`.<br>
:return:&nbsp;a&nbsp;list&nbsp;of&nbsp;TopicEndpointInfo&nbsp;for&nbsp;all&nbsp;the&nbsp;subscriptions&nbsp;on&nbsp;this&nbsp;topic.</tt></dd></dl>

<dl><dt><a name="dosnode-get_topic_names_and_types"><strong>get_topic_names_and_types</strong></a>(self, no_demangle: bool = False) -&gt; List[Tuple[str, List[str]]]</dt><dd><tt>Get&nbsp;a&nbsp;list&nbsp;topic&nbsp;names&nbsp;and&nbsp;types&nbsp;for&nbsp;the&nbsp;node.<br>
&nbsp;<br>
:param&nbsp;no_demangle:&nbsp;If&nbsp;``True``,&nbsp;then&nbsp;topic&nbsp;names&nbsp;and&nbsp;types&nbsp;returned&nbsp;will&nbsp;not&nbsp;be&nbsp;demangled.<br>
:return:&nbsp;List&nbsp;of&nbsp;tuples.<br>
&nbsp;&nbsp;The&nbsp;first&nbsp;element&nbsp;of&nbsp;each&nbsp;tuple&nbsp;is&nbsp;the&nbsp;topic&nbsp;name&nbsp;and&nbsp;the&nbsp;second&nbsp;element&nbsp;is&nbsp;a&nbsp;list&nbsp;of<br>
&nbsp;&nbsp;topic&nbsp;types.</tt></dd></dl>

<dl><dt><a name="dosnode-has_parameter"><strong>has_parameter</strong></a>(self, name: str) -&gt; bool</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;parameter&nbsp;is&nbsp;declared;&nbsp;False&nbsp;otherwise.</tt></dd></dl>

<dl><dt><a name="dosnode-remove_on_set_parameters_callback"><strong>remove_on_set_parameters_callback</strong></a>(self, callback: Callable[[List[rclpy.parameter.Parameter]], rcl_interfaces.msg._set_parameters_result.SetParametersResult]) -&gt; None</dt><dd><tt>Remove&nbsp;a&nbsp;callback&nbsp;from&nbsp;list&nbsp;of&nbsp;callbacks.<br>
&nbsp;<br>
Calling&nbsp;this&nbsp;function&nbsp;will&nbsp;remove&nbsp;the&nbsp;callback&nbsp;from&nbsp;self.<strong>_parameter_callbacks</strong>&nbsp;list.<br>
&nbsp;<br>
:param&nbsp;callback:&nbsp;The&nbsp;function&nbsp;that&nbsp;is&nbsp;called&nbsp;whenever&nbsp;parameters&nbsp;are&nbsp;set&nbsp;for&nbsp;the&nbsp;node.<br>
:raises:&nbsp;ValueError&nbsp;if&nbsp;a&nbsp;callback&nbsp;is&nbsp;not&nbsp;present&nbsp;in&nbsp;the&nbsp;list&nbsp;of&nbsp;callbacks.</tt></dd></dl>

<dl><dt><a name="dosnode-remove_waitable"><strong>remove_waitable</strong></a>(self, waitable: rclpy.waitable.Waitable) -&gt; None</dt><dd><tt>Remove&nbsp;a&nbsp;Waitable&nbsp;that&nbsp;was&nbsp;previously&nbsp;added&nbsp;to&nbsp;the&nbsp;node.<br>
&nbsp;<br>
:param&nbsp;waitable:&nbsp;The&nbsp;Waitable&nbsp;to&nbsp;remove.</tt></dd></dl>

<dl><dt><a name="dosnode-resolve_service_name"><strong>resolve_service_name</strong></a>(self, service: str, *, only_expand: bool = False) -&gt; str</dt><dd><tt>Return&nbsp;a&nbsp;service&nbsp;name&nbsp;expanded&nbsp;and&nbsp;remapped.<br>
&nbsp;<br>
:param&nbsp;service:&nbsp;service&nbsp;name&nbsp;to&nbsp;be&nbsp;expanded&nbsp;and&nbsp;remapped.<br>
:param&nbsp;only_expand:&nbsp;if&nbsp;`True`,&nbsp;remapping&nbsp;rules&nbsp;won't&nbsp;be&nbsp;applied.<br>
:return:&nbsp;a&nbsp;fully&nbsp;qualified&nbsp;service&nbsp;name,<br>
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;of&nbsp;applying&nbsp;expansion&nbsp;and&nbsp;remapping&nbsp;to&nbsp;the&nbsp;given&nbsp;`service`.</tt></dd></dl>

<dl><dt><a name="dosnode-resolve_topic_name"><strong>resolve_topic_name</strong></a>(self, topic: str, *, only_expand: bool = False) -&gt; str</dt><dd><tt>Return&nbsp;a&nbsp;topic&nbsp;name&nbsp;expanded&nbsp;and&nbsp;remapped.<br>
&nbsp;<br>
:param&nbsp;topic:&nbsp;topic&nbsp;name&nbsp;to&nbsp;be&nbsp;expanded&nbsp;and&nbsp;remapped.<br>
:param&nbsp;only_expand:&nbsp;if&nbsp;`True`,&nbsp;remapping&nbsp;rules&nbsp;won't&nbsp;be&nbsp;applied.<br>
:return:&nbsp;a&nbsp;fully&nbsp;qualified&nbsp;topic&nbsp;name,<br>
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;of&nbsp;applying&nbsp;expansion&nbsp;and&nbsp;remapping&nbsp;to&nbsp;the&nbsp;given&nbsp;`topic`.</tt></dd></dl>

<dl><dt><a name="dosnode-set_descriptor"><strong>set_descriptor</strong></a>(self, name: str, descriptor: rcl_interfaces.msg._parameter_descriptor.ParameterDescriptor, alternative_value: Optional[rcl_interfaces.msg._parameter_value.ParameterValue] = None) -&gt; rcl_interfaces.msg._parameter_value.ParameterValue</dt><dd><tt>Set&nbsp;a&nbsp;new&nbsp;descriptor&nbsp;for&nbsp;a&nbsp;given&nbsp;parameter.<br>
&nbsp;<br>
The&nbsp;name&nbsp;in&nbsp;the&nbsp;descriptor&nbsp;is&nbsp;ignored&nbsp;and&nbsp;set&nbsp;to&nbsp;**name**.<br>
&nbsp;<br>
:param&nbsp;name:&nbsp;Fully-qualified&nbsp;name&nbsp;of&nbsp;the&nbsp;parameter&nbsp;to&nbsp;set&nbsp;the&nbsp;descriptor&nbsp;to.<br>
:param&nbsp;descriptor:&nbsp;New&nbsp;descriptor&nbsp;to&nbsp;apply&nbsp;to&nbsp;the&nbsp;parameter.<br>
:param&nbsp;alternative_value:&nbsp;Value&nbsp;to&nbsp;set&nbsp;to&nbsp;the&nbsp;parameter&nbsp;if&nbsp;the&nbsp;existing&nbsp;value&nbsp;does&nbsp;not<br>
&nbsp;&nbsp;&nbsp;&nbsp;comply&nbsp;with&nbsp;the&nbsp;new&nbsp;descriptor.<br>
:return:&nbsp;ParameterValue&nbsp;for&nbsp;the&nbsp;given&nbsp;parameter&nbsp;name&nbsp;after&nbsp;applying&nbsp;the&nbsp;new&nbsp;descriptor.<br>
:raises:&nbsp;ParameterNotDeclaredException&nbsp;if&nbsp;parameter&nbsp;had&nbsp;not&nbsp;been&nbsp;declared&nbsp;before<br>
&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;undeclared&nbsp;parameters&nbsp;are&nbsp;not&nbsp;allowed.<br>
:raises:&nbsp;ParameterImmutableException&nbsp;if&nbsp;the&nbsp;parameter&nbsp;exists&nbsp;and&nbsp;is&nbsp;read-only.<br>
:raises:&nbsp;ParameterValueException&nbsp;if&nbsp;neither&nbsp;the&nbsp;existing&nbsp;value&nbsp;nor&nbsp;the&nbsp;alternative&nbsp;value<br>
&nbsp;&nbsp;&nbsp;&nbsp;complies&nbsp;with&nbsp;the&nbsp;provided&nbsp;descriptor.</tt></dd></dl>

<dl><dt><a name="dosnode-set_parameters"><strong>set_parameters</strong></a>(self, parameter_list: List[rclpy.parameter.Parameter]) -&gt; List[rcl_interfaces.msg._set_parameters_result.SetParametersResult]</dt><dd><tt>Set&nbsp;parameters&nbsp;for&nbsp;the&nbsp;node,&nbsp;and&nbsp;return&nbsp;the&nbsp;result&nbsp;for&nbsp;the&nbsp;set&nbsp;action.<br>
&nbsp;<br>
If&nbsp;any&nbsp;parameter&nbsp;in&nbsp;the&nbsp;list&nbsp;was&nbsp;not&nbsp;declared&nbsp;beforehand&nbsp;and&nbsp;undeclared&nbsp;parameters&nbsp;are&nbsp;not<br>
allowed&nbsp;for&nbsp;the&nbsp;node,&nbsp;this&nbsp;method&nbsp;will&nbsp;raise&nbsp;a&nbsp;ParameterNotDeclaredException&nbsp;exception.<br>
&nbsp;<br>
Parameters&nbsp;are&nbsp;set&nbsp;in&nbsp;the&nbsp;order&nbsp;they&nbsp;are&nbsp;declared&nbsp;in&nbsp;the&nbsp;list.<br>
If&nbsp;setting&nbsp;a&nbsp;parameter&nbsp;fails&nbsp;due&nbsp;to&nbsp;not&nbsp;being&nbsp;declared,&nbsp;then&nbsp;the<br>
parameters&nbsp;which&nbsp;have&nbsp;already&nbsp;been&nbsp;set&nbsp;will&nbsp;stay&nbsp;set,&nbsp;and&nbsp;no&nbsp;attempt&nbsp;will<br>
be&nbsp;made&nbsp;to&nbsp;set&nbsp;the&nbsp;parameters&nbsp;which&nbsp;come&nbsp;after.<br>
&nbsp;<br>
If&nbsp;undeclared&nbsp;parameters&nbsp;are&nbsp;allowed,&nbsp;then&nbsp;all&nbsp;the&nbsp;parameters&nbsp;will&nbsp;be&nbsp;implicitly<br>
declared&nbsp;before&nbsp;being&nbsp;set&nbsp;even&nbsp;if&nbsp;they&nbsp;were&nbsp;not&nbsp;declared&nbsp;beforehand.<br>
Parameter&nbsp;overrides&nbsp;are&nbsp;ignored&nbsp;by&nbsp;this&nbsp;method.<br>
&nbsp;<br>
If&nbsp;a&nbsp;callback&nbsp;was&nbsp;registered&nbsp;previously&nbsp;with&nbsp;:func:`add_on_set_parameters_callback`,&nbsp;it<br>
will&nbsp;be&nbsp;called&nbsp;prior&nbsp;to&nbsp;setting&nbsp;the&nbsp;parameters&nbsp;for&nbsp;the&nbsp;node,&nbsp;once&nbsp;for&nbsp;each&nbsp;parameter.<br>
If&nbsp;the&nbsp;callback&nbsp;prevents&nbsp;a&nbsp;parameter&nbsp;from&nbsp;being&nbsp;set,&nbsp;then&nbsp;it&nbsp;will&nbsp;be&nbsp;reflected&nbsp;in&nbsp;the<br>
returned&nbsp;result;&nbsp;no&nbsp;exceptions&nbsp;will&nbsp;be&nbsp;raised&nbsp;in&nbsp;this&nbsp;case.<br>
For&nbsp;each&nbsp;successfully&nbsp;set&nbsp;parameter,&nbsp;a&nbsp;:class:`ParameterEvent`&nbsp;message&nbsp;is<br>
published.<br>
&nbsp;<br>
If&nbsp;the&nbsp;value&nbsp;type&nbsp;of&nbsp;the&nbsp;parameter&nbsp;is&nbsp;NOT_SET,&nbsp;and&nbsp;the&nbsp;existing&nbsp;parameter&nbsp;type&nbsp;is<br>
something&nbsp;else,&nbsp;then&nbsp;the&nbsp;parameter&nbsp;will&nbsp;be&nbsp;implicitly&nbsp;undeclared.<br>
&nbsp;<br>
:param&nbsp;parameter_list:&nbsp;The&nbsp;list&nbsp;of&nbsp;parameters&nbsp;to&nbsp;set.<br>
:return:&nbsp;The&nbsp;result&nbsp;for&nbsp;each&nbsp;set&nbsp;action&nbsp;as&nbsp;a&nbsp;list.<br>
:raises:&nbsp;ParameterNotDeclaredException&nbsp;if&nbsp;undeclared&nbsp;parameters&nbsp;are&nbsp;not&nbsp;allowed,<br>
&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;at&nbsp;least&nbsp;one&nbsp;parameter&nbsp;in&nbsp;the&nbsp;list&nbsp;hadn't&nbsp;been&nbsp;declared&nbsp;beforehand.</tt></dd></dl>

<dl><dt><a name="dosnode-set_parameters_atomically"><strong>set_parameters_atomically</strong></a>(self, parameter_list: List[rclpy.parameter.Parameter]) -&gt; rcl_interfaces.msg._set_parameters_result.SetParametersResult</dt><dd><tt>Set&nbsp;the&nbsp;given&nbsp;parameters,&nbsp;all&nbsp;at&nbsp;one&nbsp;time,&nbsp;and&nbsp;then&nbsp;aggregate&nbsp;result.<br>
&nbsp;<br>
If&nbsp;any&nbsp;parameter&nbsp;in&nbsp;the&nbsp;list&nbsp;was&nbsp;not&nbsp;declared&nbsp;beforehand&nbsp;and&nbsp;undeclared&nbsp;parameters&nbsp;are&nbsp;not<br>
allowed&nbsp;for&nbsp;the&nbsp;node,&nbsp;this&nbsp;method&nbsp;will&nbsp;raise&nbsp;a&nbsp;ParameterNotDeclaredException&nbsp;exception.<br>
&nbsp;<br>
Parameters&nbsp;are&nbsp;set&nbsp;all&nbsp;at&nbsp;once.<br>
If&nbsp;setting&nbsp;a&nbsp;parameter&nbsp;fails&nbsp;due&nbsp;to&nbsp;not&nbsp;being&nbsp;declared,&nbsp;then&nbsp;no&nbsp;parameter&nbsp;will&nbsp;be&nbsp;set&nbsp;set.<br>
Either&nbsp;all&nbsp;of&nbsp;the&nbsp;parameters&nbsp;are&nbsp;set&nbsp;or&nbsp;none&nbsp;of&nbsp;them&nbsp;are&nbsp;set.<br>
&nbsp;<br>
If&nbsp;undeclared&nbsp;parameters&nbsp;are&nbsp;allowed&nbsp;for&nbsp;the&nbsp;node,&nbsp;then&nbsp;all&nbsp;the&nbsp;parameters&nbsp;will&nbsp;be<br>
implicitly&nbsp;declared&nbsp;before&nbsp;being&nbsp;set&nbsp;even&nbsp;if&nbsp;they&nbsp;were&nbsp;not&nbsp;declared&nbsp;beforehand.<br>
&nbsp;<br>
If&nbsp;a&nbsp;callback&nbsp;was&nbsp;registered&nbsp;previously&nbsp;with&nbsp;:func:`add_on_set_parameters_callback`,&nbsp;it<br>
will&nbsp;be&nbsp;called&nbsp;prior&nbsp;to&nbsp;setting&nbsp;the&nbsp;parameters&nbsp;for&nbsp;the&nbsp;node&nbsp;only&nbsp;once&nbsp;for&nbsp;all&nbsp;parameters.<br>
If&nbsp;the&nbsp;callback&nbsp;prevents&nbsp;the&nbsp;parameters&nbsp;from&nbsp;being&nbsp;set,&nbsp;then&nbsp;it&nbsp;will&nbsp;be&nbsp;reflected&nbsp;in&nbsp;the<br>
returned&nbsp;result;&nbsp;no&nbsp;exceptions&nbsp;will&nbsp;be&nbsp;raised&nbsp;in&nbsp;this&nbsp;case.<br>
For&nbsp;each&nbsp;successfully&nbsp;set&nbsp;parameter,&nbsp;a&nbsp;:class:`ParameterEvent`&nbsp;message&nbsp;is&nbsp;published.<br>
&nbsp;<br>
If&nbsp;the&nbsp;value&nbsp;type&nbsp;of&nbsp;the&nbsp;parameter&nbsp;is&nbsp;NOT_SET,&nbsp;and&nbsp;the&nbsp;existing&nbsp;parameter&nbsp;type&nbsp;is<br>
something&nbsp;else,&nbsp;then&nbsp;the&nbsp;parameter&nbsp;will&nbsp;be&nbsp;implicitly&nbsp;undeclared.<br>
&nbsp;<br>
:param&nbsp;parameter_list:&nbsp;The&nbsp;list&nbsp;of&nbsp;parameters&nbsp;to&nbsp;set.<br>
:return:&nbsp;Aggregate&nbsp;result&nbsp;of&nbsp;setting&nbsp;all&nbsp;the&nbsp;parameters&nbsp;atomically.<br>
:raises:&nbsp;ParameterNotDeclaredException&nbsp;if&nbsp;undeclared&nbsp;parameters&nbsp;are&nbsp;not&nbsp;allowed,<br>
&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;at&nbsp;least&nbsp;one&nbsp;parameter&nbsp;in&nbsp;the&nbsp;list&nbsp;hadn't&nbsp;been&nbsp;declared&nbsp;beforehand.</tt></dd></dl>

<dl><dt><a name="dosnode-undeclare_parameter"><strong>undeclare_parameter</strong></a>(self, name: str)</dt><dd><tt>Undeclare&nbsp;a&nbsp;previously&nbsp;declared&nbsp;parameter.<br>
&nbsp;<br>
This&nbsp;method&nbsp;will&nbsp;not&nbsp;cause&nbsp;a&nbsp;callback&nbsp;registered&nbsp;with<br>
:func:`add_on_set_parameters_callback`&nbsp;to&nbsp;be&nbsp;called.<br>
&nbsp;<br>
:param&nbsp;name:&nbsp;Fully-qualified&nbsp;name&nbsp;of&nbsp;the&nbsp;parameter,&nbsp;including&nbsp;its&nbsp;namespace.<br>
:raises:&nbsp;ParameterNotDeclaredException&nbsp;if&nbsp;parameter&nbsp;had&nbsp;not&nbsp;been&nbsp;declared&nbsp;before.<br>
:raises:&nbsp;ParameterImmutableException&nbsp;if&nbsp;the&nbsp;parameter&nbsp;was&nbsp;created&nbsp;as&nbsp;read-only.</tt></dd></dl>

<hr>
Readonly properties inherited from <a href="rclpy.node.html#Node">rclpy.node.Node</a>:<br>
<dl><dt><strong>clients</strong></dt>
<dd><tt>Get&nbsp;clients&nbsp;that&nbsp;have&nbsp;been&nbsp;created&nbsp;on&nbsp;this&nbsp;node.</tt></dd>
</dl>
<dl><dt><strong>context</strong></dt>
<dd><tt>Get&nbsp;the&nbsp;context&nbsp;associated&nbsp;with&nbsp;the&nbsp;node.</tt></dd>
</dl>
<dl><dt><strong>default_callback_group</strong></dt>
<dd><tt>Get&nbsp;the&nbsp;default&nbsp;callback&nbsp;group.<br>
&nbsp;<br>
If&nbsp;no&nbsp;other&nbsp;callback&nbsp;group&nbsp;is&nbsp;provided&nbsp;when&nbsp;the&nbsp;a&nbsp;ROS&nbsp;entity&nbsp;is&nbsp;created&nbsp;with&nbsp;the&nbsp;node,<br>
then&nbsp;it&nbsp;is&nbsp;added&nbsp;to&nbsp;the&nbsp;default&nbsp;callback&nbsp;group.</tt></dd>
</dl>
<dl><dt><strong>guards</strong></dt>
<dd><tt>Get&nbsp;guards&nbsp;that&nbsp;have&nbsp;been&nbsp;created&nbsp;on&nbsp;this&nbsp;node.</tt></dd>
</dl>
<dl><dt><strong>publishers</strong></dt>
<dd><tt>Get&nbsp;publishers&nbsp;that&nbsp;have&nbsp;been&nbsp;created&nbsp;on&nbsp;this&nbsp;node.</tt></dd>
</dl>
<dl><dt><strong>services</strong></dt>
<dd><tt>Get&nbsp;services&nbsp;that&nbsp;have&nbsp;been&nbsp;created&nbsp;on&nbsp;this&nbsp;node.</tt></dd>
</dl>
<dl><dt><strong>subscriptions</strong></dt>
<dd><tt>Get&nbsp;subscriptions&nbsp;that&nbsp;have&nbsp;been&nbsp;created&nbsp;on&nbsp;this&nbsp;node.</tt></dd>
</dl>
<dl><dt><strong>timers</strong></dt>
<dd><tt>Get&nbsp;timers&nbsp;that&nbsp;have&nbsp;been&nbsp;created&nbsp;on&nbsp;this&nbsp;node.</tt></dd>
</dl>
<dl><dt><strong>waitables</strong></dt>
<dd><tt>Get&nbsp;waitables&nbsp;that&nbsp;have&nbsp;been&nbsp;created&nbsp;on&nbsp;this&nbsp;node.</tt></dd>
</dl>
<hr>
Data descriptors inherited from <a href="rclpy.node.html#Node">rclpy.node.Node</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>executor</strong></dt>
<dd><tt>Get&nbsp;the&nbsp;executor&nbsp;if&nbsp;the&nbsp;node&nbsp;has&nbsp;been&nbsp;added&nbsp;to&nbsp;one,&nbsp;else&nbsp;return&nbsp;``None``.</tt></dd>
</dl>
<dl><dt><strong>handle</strong></dt>
<dd><tt>Get&nbsp;the&nbsp;handle&nbsp;to&nbsp;the&nbsp;underlying&nbsp;`rcl_node_t`.<br>
&nbsp;<br>
Cannot&nbsp;be&nbsp;modified&nbsp;after&nbsp;node&nbsp;creation.<br>
&nbsp;<br>
:raises:&nbsp;AttributeError&nbsp;if&nbsp;modified&nbsp;after&nbsp;creation.</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="rclpy.node.html#Node">rclpy.node.Node</a>:<br>
<dl><dt><strong>PARAM_REL_TOL</strong> = 1e-06</dl>

</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#eeaa77">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Functions</strong></big></font></td></tr>
    
<tr><td bgcolor="#eeaa77"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl><dt><a name="-checkService"><strong>checkService</strong></a>(node)</dt><dd><tt>Checks&nbsp;if&nbsp;the&nbsp;<a href="rclpy.node.html#Node">Node</a>&nbsp;is&nbsp;available.&nbsp;Otherwise,&nbsp;it&nbsp;kills&nbsp;the&nbsp;execution.<br>
&nbsp;<br>
Parameters<br>
----------<br>
node:&nbsp;<a href="rclpy.node.html#Node">Node</a>&nbsp;The&nbsp;node</tt></dd></dl>
 <dl><dt><a name="-dosFillService"><strong>dosFillService</strong></a>(mydosnode, nodeObjectiveServer, nodeObjectiveType, workers)</dt><dd><tt>Launches&nbsp;an&nbsp;attack&nbsp;against&nbsp;ROS2&nbsp;services.&nbsp;This&nbsp;functions&nbsp;organizes&nbsp;the&nbsp;process.<br>
&nbsp;<br>
Parameters<br>
----------<br>
mydosnode:&nbsp;<a href="rclpy.node.html#Node">Node</a>,&nbsp;The&nbsp;node&nbsp;we&nbsp;use&nbsp;to&nbsp;orchestrate&nbsp;the&nbsp;attack<br>
nodeObjectiveServer:&nbsp;String,&nbsp;the&nbsp;service&nbsp;we&nbsp;are&nbsp;goint&nbsp;to&nbsp;attack<br>
nodeObjectiveType:&nbsp;String,&nbsp;the&nbsp;type&nbsp;of&nbsp;the&nbsp;service&nbsp;we&nbsp;are&nbsp;goint&nbsp;to&nbsp;attack<br>
workers:&nbsp;The&nbsp;number&nbsp;of&nbsp;simultaneous&nbsp;attacks&nbsp;we&nbsp;are&nbsp;going&nbsp;to&nbsp;launch.</tt></dd></dl>
 <dl><dt><a name="-dosFillServiceAux"><strong>dosFillServiceAux</strong></a>(sclient, request)</dt><dd><tt>Launches&nbsp;an&nbsp;attack&nbsp;against&nbsp;ROS2&nbsp;services.&nbsp;This&nbsp;functions&nbsp;makes&nbsp;the&nbsp;actual&nbsp;connection<br>
&nbsp;<br>
Parameters<br>
----------<br>
sclient:&nbsp;Client,&nbsp;this&nbsp;is&nbsp;the&nbsp;client&nbsp;connected&nbsp;to&nbsp;the&nbsp;objective&nbsp;node<br>
request:&nbsp;Multiform.&nbsp;Can&nbsp;be&nbsp;any&nbsp;type&nbsp;of&nbsp;ROS2&nbsp;request&nbsp;type</tt></dd></dl>
 <dl><dt><a name="-dosSendPing"><strong>dosSendPing</strong></a>(ipdest, workers)</dt><dd><tt>Launches&nbsp;a&nbsp;ping&nbsp;attack&nbsp;against&nbsp;the&nbsp;machine&nbsp;objective.&nbsp;This&nbsp;functions&nbsp;organizes&nbsp;the&nbsp;process.<br>
&nbsp;<br>
Parameters<br>
----------<br>
ipdest:&nbsp;String,&nbsp;The&nbsp;ip&nbsp;to&nbsp;attack&nbsp;to.<br>
workers:&nbsp;The&nbsp;number&nbsp;of&nbsp;simultaneous&nbsp;attacks&nbsp;we&nbsp;are&nbsp;going&nbsp;to&nbsp;launch.</tt></dd></dl>
 <dl><dt><a name="-dosSendPingAux"><strong>dosSendPingAux</strong></a>(ip)</dt><dd><tt>Launches&nbsp;a&nbsp;ping&nbsp;attack&nbsp;against&nbsp;the&nbsp;machine&nbsp;objective.&nbsp;This&nbsp;functions&nbsp;makes&nbsp;the&nbsp;actual&nbsp;work&nbsp;of&nbsp;sending&nbsp;ping<br>
&nbsp;<br>
Parameters<br>
----------<br>
ip:&nbsp;String,&nbsp;The&nbsp;ip&nbsp;to&nbsp;attack&nbsp;to.</tt></dd></dl>
 <dl><dt><a name="-dosSendRandomGarbageAuxTCP"><strong>dosSendRandomGarbageAuxTCP</strong></a>(ip, node, port, socketObject)</dt><dd><tt>Launches&nbsp;garbage&nbsp;into&nbsp;selected&nbsp;ports&nbsp;&nbsp;via&nbsp;TCP.&nbsp;This&nbsp;functions&nbsp;makes&nbsp;the&nbsp;actual&nbsp;work&nbsp;of&nbsp;sending&nbsp;garbage<br>
&nbsp;<br>
Parameters<br>
----------<br>
node:&nbsp;<a href="rclpy.node.html#Node">Node</a>,&nbsp;The&nbsp;node&nbsp;<br>
ip:&nbsp;String,&nbsp;The&nbsp;ip&nbsp;to&nbsp;attack&nbsp;to.<br>
port:&nbsp;String,&nbsp;the&nbsp;port&nbsp;which&nbsp;will&nbsp;be&nbsp;attacked.<br>
socketObject:&nbsp;Socket,&nbsp;the&nbsp;needed&nbsp;socket</tt></dd></dl>
 <dl><dt><a name="-dosSendRandomGarbageAuxUDP"><strong>dosSendRandomGarbageAuxUDP</strong></a>(ip, node, port, socketObject)</dt><dd><tt>Launches&nbsp;garbage&nbsp;into&nbsp;selected&nbsp;ports&nbsp;&nbsp;via&nbsp;UDP.&nbsp;This&nbsp;functions&nbsp;makes&nbsp;the&nbsp;actual&nbsp;work&nbsp;of&nbsp;sending&nbsp;garbage<br>
&nbsp;<br>
Parameters<br>
----------<br>
node:&nbsp;<a href="rclpy.node.html#Node">Node</a>,&nbsp;The&nbsp;node&nbsp;<br>
ip:&nbsp;String,&nbsp;The&nbsp;ip&nbsp;to&nbsp;attack&nbsp;to.<br>
port:&nbsp;String,&nbsp;the&nbsp;port&nbsp;which&nbsp;will&nbsp;be&nbsp;attacked.<br>
socketObject:&nbsp;Socket,&nbsp;the&nbsp;needed&nbsp;socket</tt></dd></dl>
 <dl><dt><a name="-dosSendRandomGarbageTCP"><strong>dosSendRandomGarbageTCP</strong></a>(ipdest, node, ports, socketObject)</dt><dd><tt>Launches&nbsp;garbage&nbsp;into&nbsp;selected&nbsp;ports&nbsp;via&nbsp;TCP.&nbsp;This&nbsp;functions&nbsp;organizes&nbsp;the&nbsp;process.<br>
&nbsp;<br>
Parameters<br>
----------<br>
node:&nbsp;<a href="rclpy.node.html#Node">Node</a>,&nbsp;The&nbsp;node&nbsp;<br>
ipdest:&nbsp;String,&nbsp;The&nbsp;ip&nbsp;to&nbsp;attack&nbsp;to.<br>
ports:&nbsp;List,&nbsp;A&nbsp;list&nbsp;of&nbsp;ports<br>
socketObject:&nbsp;Socket,&nbsp;the&nbsp;needed&nbsp;socket</tt></dd></dl>
 <dl><dt><a name="-dosSendRandomGarbageUDP"><strong>dosSendRandomGarbageUDP</strong></a>(ipdest, node, ports, socketObject)</dt><dd><tt>Launches&nbsp;garbage&nbsp;into&nbsp;selected&nbsp;ports&nbsp;via&nbsp;UDP.&nbsp;This&nbsp;functions&nbsp;organizes&nbsp;the&nbsp;process.<br>
&nbsp;<br>
Parameters<br>
----------<br>
node:&nbsp;<a href="rclpy.node.html#Node">Node</a>,&nbsp;The&nbsp;node&nbsp;<br>
ipdest:&nbsp;String,&nbsp;The&nbsp;ip&nbsp;to&nbsp;attack&nbsp;to.<br>
ports:&nbsp;List,&nbsp;A&nbsp;list&nbsp;of&nbsp;ports<br>
socketObject:&nbsp;Socket,&nbsp;the&nbsp;needed&nbsp;socket</tt></dd></dl>
 <dl><dt><a name="-main"><strong>main</strong></a>()</dt></dl>
 <dl><dt><a name="-printargs"><strong>printargs</strong></a>(node)</dt><dd><tt>Prints&nbsp;every&nbsp;param&nbsp;present&nbsp;in&nbsp;the&nbsp;node&nbsp;and&nbsp;its&nbsp;values<br>
&nbsp;<br>
Parameters<br>
----------<br>
node:&nbsp;<a href="rclpy.node.html#Node">Node</a>&nbsp;The&nbsp;node</tt></dd></dl>
</td></tr></table>
</body></html>